/**
 * @file src/services/groups.ts
 * @description Service for all group-buy-related database operations.
 * The critical 'joinGroup' action now uses an atomic RPC for data safety.
 * All other functions are also updated to align with the latest database schema.
 * Adherence to "Violent Psychopath Maintenance Standard":
 * - Explicit JSDoc for all functions and important logic.
 * - Strong typing for all parameters and return values.
 * - Centralized error handling.
 * - Clear distinction between client-side utility functions and database interactions.
 */
import { supabase, handleSupabaseError, createRealtimeSubscription } from './supabase';
// Import specific types for clarity and safety.
import type { GroupBuy, CreateGroupRequest, GroupParticipant, GroupStatus } from '@/types/groups';
import type { Product } from '@/types/products';
import type { User }
from '@/types/auth'; // For typing nested user data

/**
 * @interface FullGroupBuy
 * @description Extends the base GroupBuy type to include nested product and participant details,
 * as often fetched from the database for display purposes.
 */
export interface FullGroupBuy extends GroupBuy {
  product?: Product; // The product associated with this group buy.
  participants?: (GroupParticipant & { user?: Pick<User, 'id' | 'displayName' | 'avatarUrl'> })[];
}

export class GroupBuyingService {
  /**
   * Client-side utility to calculate dynamic group price.
   * This logic is IDENTICAL to the `calculate_group_price` SQL function
   * for frontend display purposes (e.g., showing potential savings).
   * The canonical price calculation happens in the database.
   * @param {number} basePrice - The product's original price.
   * @param {number} quantity - The current total quantity in the group.
   * @returns {number} The calculated discounted price per unit.
   */
  static calculateGroupPrice(basePrice: number, quantity: number): number {
    let discountedPrice: number;
    if (quantity >= 20) {
      discountedPrice = basePrice * 0.8; // 20% off
    } else if (quantity >= 10) {
      discountedPrice = basePrice * 0.9; // 10% off
    } else if (quantity >= 5) {
      discountedPrice = basePrice * 0.95;  // 5% off
    } else {
      discountedPrice = basePrice;
    }
    // Ensure currency-safe rounding.
    return Math.round(discountedPrice * 100) / 100;
  }

  /**
   * Creates a new group buy.
   * The `invite_code` is now generated by a database trigger (`set_invite_code` from your schema).
   * The initial `current_price_per_unit` is set to the product's `basePrice`.
   * @param {CreateGroupRequest} request - Data for the new group.
   * @returns {Promise<{ success: boolean; data?: GroupBuy; error?: string }>} Result object.
   */
  static async createGroup(request: CreateGroupRequest): Promise<{ success: boolean; data?: GroupBuy; error?: string }> {
    try {
      // The database schema for `group_buys` expects `creator_id` and `end_date`.
      // The `unit_price` in `group_buys` table refers to the fixed price for that group.
      const groupToInsert = {
        product_id: request.productId,
        creator_id: request.initiatorId,
        title: request.title, // Assuming title is part of CreateGroupRequest
        target_quantity: request.targetQuantity,
        current_quantity: 0, // A new group starts with 0 participants' quantity.
        unit_price: request.basePrice, // This is the price for THIS group, set at creation.
        // `current_price_per_unit` in the DB table represents the effective price for this group.
        // If your DB schema has `current_price_per_unit` instead of `unit_price` for fixed group price, adjust here.
        // The current `rough_fire.sql` has `unit_price` for group_buys.
        // And `group_participants` also has a `unit_price` column.
        // Let's assume `group_buys.unit_price` is the price members pay for THIS group.
        end_date: request.deadline, // SQL schema uses 'end_date'.
        delivery_method: request.deliveryMethod,
        // Region is not in the `CreateGroupRequest` type but in the `group_buys` table from the migration.
        // Adding it based on the migration file.
        // If `request.region` is not passed, this might need a default or be made mandatory.
        // region: request.region, // This was missing in the original `groups.ts` but in your db schema
        is_public: true, // Defaulting to public.
        status: 'forming' as GroupStatus,
        // `invite_code` is handled by the SQL trigger.
      };

      const { data, error } = await supabase
        .from('group_buys')
        .insert(groupToInsert)
        .select()
        .single();

      if (error) throw error;
      return { success: true, data: data as GroupBuy };
    } catch (error: any) {
      return { success: false, error: handleSupabaseError(error) };
    }
  }

  /**
   * Joins a user to an existing group buy by calling the atomic `join_group_atomic` database function.
   * This ensures data integrity by performing all checks and updates in a single transaction.
   * @param {string} groupId - The ID of the group to join.
   * @param {string} userId - The ID of the user joining.
   * @param {number} quantity - The number of items the user is committing to.
   * @returns {Promise<{ success: boolean; error?: string; newGroupPrice?: number }>} Result object.
   * Includes `newGroupPrice` if the join was successful.
   */
  static async joinGroup(groupId: string, userId: string, quantity: number): Promise<{ success: boolean; error?: string; newGroupPrice?: number }> {
    try {
      // Call the PL/pgSQL function. Parameters must match the function definition.
      const { data, error: rpcError } = await supabase.rpc('join_group_atomic', {
        p_group_id_input: groupId, // Matches argument name in SQL function
        p_user_id_input: userId,   // Matches argument name in SQL function
        p_quantity_input: quantity // Matches argument name in SQL function
      });

      if (rpcError) {
        // This catches errors from the RPC call itself (e.g., network, function not found).
        console.error('RPC error in joinGroup:', rpcError);
        throw rpcError;
      }
      
      // The RPC function returns an array with a single object: { success: boolean, message: text, new_group_price: decimal }
      // We need to access the first element.
      const result = data?.[0];

      if (!result) {
        // This case should ideally not happen if the RPC is well-behaved.
        console.error('RPC call to join_group_atomic returned no data.');
        throw new Error('Server did not confirm the join operation.');
      }

      if (!result.success) {
        // This handles logical errors returned BY the SQL function.
        console.warn('Join group attempt failed (handled by DB):', result.message);
        throw new Error(result.message);
      }

      // If the SQL function signals success.
      return { success: true, newGroupPrice: result.new_group_price };

    } catch (error: any) {
      // This catches errors from the RPC call, or errors thrown from the `!result.success` block.
      return { 
        success: false, 
        error: error.message || 'An unexpected error occurred while joining the group.'
      };
    }
  }

  /**
   * Fetches detailed information for a specific group buy.
   * Includes associated product details and participant information (with user display names).
   * @param {string} groupId - The ID of the group buy to fetch.
   * @returns {Promise<{ success: boolean; data?: FullGroupBuy; error?: string }>} Result object.
   */
  static async getGroupDetails(groupId: string): Promise<{ success: boolean; data?: FullGroupBuy; error?: string }> {
    try {
      const { data: group, error } = await supabase
        .from('group_buys')
        .select(`
          id,
          product_id,
          creator_id,
          title,
          description,
          target_quantity,
          current_quantity,
          unit_price,
          invite_code,
          status,
          end_date, -- Aliased from 'deadline' in CreateGroupPage for consistency with DB
          delivery_method,
          created_at,
          updated_at,
          product:products (
            id, name, description, price, images, unit,
            farmer:users!farmer_id (id, display_name, avatar_url)
          ),
          participants:group_participants (
            id, user_id, quantity, unit_price, joined_at, status,
            user:users!user_id (id, display_name, avatar_url)
          )
        `)
        .eq('id', groupId)
        .single();

      if (error) throw error;
      if (!group) return { success: false, error: 'Group not found.' };

      return { success: true, data: group as FullGroupBuy };
    } catch (error: any) {
      return { success: false, error: handleSupabaseError(error) };
    }
  }

  /**
   * Fetches a list of group buys that are currently 'forming' or 'active'.
   * Optionally filters by region. Results are ordered by creation date (newest first).
   * @param {string} [region] - Optional. The region to filter group buys by. (Not in current DB schema for group_buys)
   * @param {number} [limit=20] - Optional. Maximum number of groups to fetch.
   * @returns {Promise<{ success: boolean; data?: FullGroupBuy[]; error?: string }>} Result object.
   */
  static async getActiveGroups(region?: string, limit: number = 20): Promise<{ success: boolean; data?: FullGroupBuy[]; error?: string }> {
    try {
      let query = supabase
        .from('group_buys')
        .select(`
          id, product_id, title, target_quantity, current_quantity, unit_price, status, end_date, invite_code,
          product:products (name, images, unit, farmer:users!farmer_id(display_name)),
          participants:group_participants(count)
        `)
        .in('status', ['forming' as GroupStatus, 'active' as GroupStatus]) // Explicitly cast for type safety
        .order('created_at', { ascending: false })
        .limit(limit);

      // The current group_buys schema (from rough_fire.sql) does NOT have a 'region' column.
      // If region filtering is desired for groups, the schema needs to be updated,
      // or filtering must happen based on the product's farmer's region (more complex client-side or via DB view).
      // For now, this filter is commented out as it would fail.
      /*
      if (region) {
        query = query.eq('region', region); // This line would cause an error.
      }
      */

      const { data: groups, error } = await query;

      if (error) throw error;
      return { success: true, data: (groups as FullGroupBuy[]) || [] };
    } catch (error: any) {
      return { success: false, error: handleSupabaseError(error) };
    }
  }

  /**
   * Subscribes to real-time changes for participants of a specific group.
   * Useful for live UI updates (e.g., participant count, progress bar).
   * @param {string} groupId - The ID of the group to listen to.
   * @param {(payload: any) => void} callback - Function to execute on change.
   * @returns {ReturnType<typeof createRealtimeSubscription>} Supabase channel subscription.
   */
  static subscribeToGroupParticipants(groupId: string, callback: (payload: any) => void) {
    return createRealtimeSubscription(
      'group_participants', // Table to listen on.
      callback,
      `group_id=eq.${groupId}` // Filter for the specific group.
    );
  }

  /**
   * Subscribes to real-time changes for the status or details of a specific group_buy record.
   * Useful for live updates to group status (e.g., 'forming' -> 'active').
   * @param {string} groupId - The ID of the group buy to listen to.
   * @param {(payload: any) => void} callback - Function to execute on change.
   * @returns {ReturnType<typeof createRealtimeSubscription>} Supabase channel subscription.
   */
  static subscribeToGroupStatus(groupId: string, callback: (payload: any) => void) {
    return createRealtimeSubscription(
      'group_buys', // Table to listen on.
      callback,
      `id=eq.${groupId}` // Filter for the specific group.
    );
  }
}

